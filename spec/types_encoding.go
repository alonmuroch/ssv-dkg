// Code generated by fastssz. DO NOT EDIT.
// Hash: be943593f0c0ce5c9d39fb2ebf6b73f92e429b4fa3d1ea5a90010643929a5480
// Version: 0.1.3
package spec

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Proof object
func (p *Proof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the Proof object to a target array
func (p *Proof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(184)

	// Field (0) 'ValidatorPubKey'
	if size := len(p.ValidatorPubKey); size != 64 {
		err = ssz.ErrBytesLengthFn("Proof.ValidatorPubKey", size, 64)
		return
	}
	dst = append(dst, p.ValidatorPubKey...)

	// Offset (1) 'EncryptedShare'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.EncryptedShare)

	// Field (2) 'SharePubKey'
	if size := len(p.SharePubKey); size != 96 {
		err = ssz.ErrBytesLengthFn("Proof.SharePubKey", size, 96)
		return
	}
	dst = append(dst, p.SharePubKey...)

	// Field (3) 'Owner'
	dst = append(dst, p.Owner[:]...)

	// Field (1) 'EncryptedShare'
	if size := len(p.EncryptedShare); size > 8528 {
		err = ssz.ErrBytesLengthFn("Proof.EncryptedShare", size, 8528)
		return
	}
	dst = append(dst, p.EncryptedShare...)

	return
}

// UnmarshalSSZ ssz unmarshals the Proof object
func (p *Proof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 184 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'ValidatorPubKey'
	if cap(p.ValidatorPubKey) == 0 {
		p.ValidatorPubKey = make([]byte, 0, len(buf[0:64]))
	}
	p.ValidatorPubKey = append(p.ValidatorPubKey, buf[0:64]...)

	// Offset (1) 'EncryptedShare'
	if o1 = ssz.ReadOffset(buf[64:68]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 184 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'SharePubKey'
	if cap(p.SharePubKey) == 0 {
		p.SharePubKey = make([]byte, 0, len(buf[68:164]))
	}
	p.SharePubKey = append(p.SharePubKey, buf[68:164]...)

	// Field (3) 'Owner'
	copy(p.Owner[:], buf[164:184])

	// Field (1) 'EncryptedShare'
	{
		buf = tail[o1:]
		if len(buf) > 8528 {
			return ssz.ErrBytesLength
		}
		if cap(p.EncryptedShare) == 0 {
			p.EncryptedShare = make([]byte, 0, len(buf))
		}
		p.EncryptedShare = append(p.EncryptedShare, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Proof object
func (p *Proof) SizeSSZ() (size int) {
	size = 184

	// Field (1) 'EncryptedShare'
	size += len(p.EncryptedShare)

	return
}

// HashTreeRoot ssz hashes the Proof object
func (p *Proof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the Proof object with a hasher
func (p *Proof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorPubKey'
	if size := len(p.ValidatorPubKey); size != 64 {
		err = ssz.ErrBytesLengthFn("Proof.ValidatorPubKey", size, 64)
		return
	}
	hh.PutBytes(p.ValidatorPubKey)

	// Field (1) 'EncryptedShare'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.EncryptedShare))
		if byteLen > 8528 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.EncryptedShare)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (8528+31)/32)
	}

	// Field (2) 'SharePubKey'
	if size := len(p.SharePubKey); size != 96 {
		err = ssz.ErrBytesLengthFn("Proof.SharePubKey", size, 96)
		return
	}
	hh.PutBytes(p.SharePubKey)

	// Field (3) 'Owner'
	hh.PutBytes(p.Owner[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Proof object
func (p *Proof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the SignedProof object
func (s *SignedProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedProof object to a target array
func (s *SignedProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(68)

	// Offset (0) 'Proof'
	dst = ssz.WriteOffset(dst, offset)
	if s.Proof == nil {
		s.Proof = new(Proof)
	}
	offset += s.Proof.SizeSSZ()

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 64 {
		err = ssz.ErrBytesLengthFn("SignedProof.Signature", size, 64)
		return
	}
	dst = append(dst, s.Signature...)

	// Field (0) 'Proof'
	if dst, err = s.Proof.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedProof object
func (s *SignedProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 68 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Proof'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 68 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	if cap(s.Signature) == 0 {
		s.Signature = make([]byte, 0, len(buf[4:68]))
	}
	s.Signature = append(s.Signature, buf[4:68]...)

	// Field (0) 'Proof'
	{
		buf = tail[o0:]
		if s.Proof == nil {
			s.Proof = new(Proof)
		}
		if err = s.Proof.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedProof object
func (s *SignedProof) SizeSSZ() (size int) {
	size = 68

	// Field (0) 'Proof'
	if s.Proof == nil {
		s.Proof = new(Proof)
	}
	size += s.Proof.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedProof object
func (s *SignedProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedProof object with a hasher
func (s *SignedProof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proof'
	if err = s.Proof.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	if size := len(s.Signature); size != 64 {
		err = ssz.ErrBytesLengthFn("SignedProof.Signature", size, 64)
		return
	}
	hh.PutBytes(s.Signature)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedProof object
func (s *SignedProof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
